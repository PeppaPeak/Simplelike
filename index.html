<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Single-file Roguelike (Prototype) - With Waves</title>
<style>
  :root{
    --ui-bg: #ffffff;
    --accent: #0b66ff;
    --card-bg: rgba(255,255,255,0.98);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:#f7f7f7;}
  #container{display:flex;justify-content:center;padding:24px;}
  canvas{background: #fff; border: 1px solid #e3e3e3; box-shadow: 0 0 0 1px rgba(0,0,0,0.02) inset;}
  /* UI */
  .ui {
    position: absolute; left:28px; top:18px; width:260px;
    background:var(--card-bg); border-radius:8px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,0.08);
    color:#222; font-size:13px;
  }
  .hp-bar {height:10px; background:#eee; border-radius:6px; overflow:hidden; margin-bottom:8px;}
  .hp-fill {height:100%; background:linear-gradient(90deg,var(--accent), #3bb0ff); width:100%;}
  .small {color:#666; font-size:12px;}
  .bottom-left {position:absolute; left:340px; bottom:40px; color:#444; font-size:13px;}
  /* Card popup */
  .overlay {position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.25); z-index:50;}
  .card-panel {background:white; padding:18px; border-radius:10px; width:740px; display:flex; gap:12px; box-shadow:0 20px 60px rgba(0,0,0,0.25);}
  .card {flex:1; border-radius:8px; padding:12px; border:1px solid #eee; cursor:pointer; transition:transform .12s ease, box-shadow .12s ease;}
  .card:hover{transform:translateY(-6px); box-shadow:0 10px 30px rgba(0,0,0,0.12);}
  .card .title{font-weight:600; margin-bottom:6px;}
  .card .desc{font-size:13px; color:#555; min-height:44px;}
  .info {font-size:13px; color:#333; margin-top:8px;}
  .muted {color:#888; font-size:12px;}
  .center {text-align:center;}
  .button {padding:8px 12px; background:var(--accent); color:white; border-radius:6px; display:inline-block; cursor:pointer;}
  footer {position:fixed; right:18px; bottom:8px; color:#999; font-size:12px;}
  .wave-desc {position:fixed; left:50%; transform:translateX(-50%); bottom:12px; background:white; padding:8px 14px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.08); color:#333; font-weight:600;}
</style>
</head>
<body>
<div id="container">
  <canvas id="game" width="1200" height="700"></canvas>
</div>

<div class="ui" id="ui">
  <div style="font-weight:700">HP</div>
  <div class="hp-bar"><div id="hpfill" class="hp-fill"></div></div>
  <div id="ui-text" class="small">XP: 0 | Level: 1 | Weapon: -</div>
  <div class="small" style="margin-top:8px">Move: WASD / Arrows</div>
</div>

<div class="bottom-left" id="bottomstats">Enemies: 0 &nbsp;&nbsp; Bullets: 0 &nbsp;&nbsp; XP:0/3</div>
<div id="waveDesc" class="wave-desc">Wave 1 - Easy: Meatshield</div>

<footer>Single-file roguelike â€¢ Kill enemies for XP & choose upgrades</footer>

<script>
/*
  Completed single-file prototype.
  - Waves (first 10 preset, then random with scaling)
  - Wave description bottom-of-screen classifies wave
  - Pentadecagon enemy added (ranged turret that keeps distance)
  - Easy-to-edit config sections near the top
*/

/* ---------------- CONFIG: tweak here ---------------- */
const CONFIG = {
  canvas: { w: 1000, h: 600 },
  maxEnemies: 20,
  player: { maxHp: 10, speed: 180 },
  xpToLevel: lvl => 3 + lvl,
  spawnDelayBetweenWaveEnemies: 220, // ms spawn within a wave
};

// Weapon templates (simplified but editable)
const WEAPON_TEMPLATES = {
  rotating_orb: { id:'rotating_orb', name:'Rotating Orb', type:'orb', baseDamage:1, data:{count:1, speed:2.2}, desc:'Rotates around player dealing damage.'},
  buckshot:      { id:'buckshot', name:'Buckshot', type:'projectile', baseDamage:1, data:{bullets:5, spread:0.55, rate:1.2, speed:380}, desc:'Shoots cluster to nearest enemy.'},
  rocket:        { id:'rocket', name:'Rocket Launcher', type:'projectile', baseDamage:3, data:{rate:0.45, speed:240, splash:28, splashDamage:2}, desc:'Slow rocket with splash.'},
  chain:         { id:'chain', name:'Chain', type:'chain', baseDamage:1, data:{range:120, chains:2, rate:1.1}, desc:'Zaps nearby enemies and chains.'},
  scythe:        { id:'scythe', name:'Scythe', type:'scythe', baseDamage:0, data:{poison:1, lifetime:1600, rate:0.8, pierce:true}, desc:'Throws a scythe that poisons.'},
  minions:       { id:'minions', name:'Minions', type:'minions', baseDamage:1, data:{count:1, spawnInterval:2500}, desc:'Spawns helper minions.'},
  ring:          { id:'ring', name:'Ring', type:'ring', baseDamage:1, data:{dirs:8, rate:0.6, speed:260}, desc:'Fires bullets in many directions.'}
};

// Upgrades per weapon (functions mutate weapon instance)
const UPGRADE_OPTIONS = {
  rotating_orb:[
    {title:'Faster Rotation', apply:w=>w.data.speed*=1.6, desc:'Orbs rotate faster.'},
    {title:'More Orbs', apply:w=>w.data.count+=1, desc:'Adds another orb.'},
    {title:'More Damage', apply:w=>w.baseDamage+=1, desc:'Orbs deal more damage.'},
  ],
  buckshot:[
    {title:'More Bullets', apply:w=>w.data.bullets+=2, desc:'Shoot more pellets.'},
    {title:'Faster Fire Rate', apply:w=>w.data.rate*=1.35, desc:'Shoot faster.'},
    {title:'More Damage', apply:w=>w.baseDamage+=1, desc:'Pellets do more damage.'},
  ],
  rocket:[
    {title:'More Damage', apply:w=>w.baseDamage+=1, desc:'Rockets hit harder.'},
    {title:'Larger Splash', apply:w=>w.data.splash+=12, desc:'Splash radius increases.'},
    {title:'More Splash Damage', apply:w=>w.data.splashDamage+=1, desc:'Increase splash damage.'},
  ],
  chain:[
    {title:'More Damage', apply:w=>w.baseDamage+=1, desc:'Chains do more damage.'},
    {title:'Faster Rate', apply:w=>w.data.rate*=1.4, desc:'Zap more often.'},
    {title:'Longer Chains', apply:w=>w.data.chains+=1, desc:'Chains chain further.'},
  ],
  scythe:[
    {title:'Longer Poison', apply:w=>w.data.lifetime+=800, desc:'Poison lasts longer.'},
    {title:'Faster Rate', apply:w=>w.data.rate*=1.3, desc:'Throw scythes more often.'},
    {title:'More Poison Damage', apply:w=>w.data.poison+=1, desc:'Poison ticks more.'},
  ],
  minions:[
    {title:'More Minions', apply:w=>w.data.count+=1, desc:'Spawn more minions.'},
    {title:'Square Minion', apply:w=>w.minionType='square', desc:'Minions become tanky squares.'},
    {title:'Faster Minion Spawns', apply:w=>w.data.spawnInterval=Math.max(600,w.data.spawnInterval*0.7), desc:'Minions spawn faster.'},
  ],
  ring:[
    {title:'More Bullets', apply:w=>w.data.dirs+=4, desc:'More directions.'},
    {title:'Faster Rate', apply:w=>w.data.rate*=1.4, desc:'Shoot ring faster.'},
    {title:'More Damage', apply:w=>w.baseDamage+=1, desc:'Ring bullets hit harder.'},
  ],
};

// Enemy templates including the new pentadecagon ranged turret.
const ENEMIES = {
  circle:      {shape:'circle', hp:3, speed:56, color:'#ff5a5a', immune:{}, xp:1},
  square:      {shape:'square', hp:9, speed:28, color:'#c93c3c', immune:{}, xp:3},
  triangle:    {shape:'triangle', hp:2, speed:120, color:'#ff8b8b', immune:{}, xp:1},
  pentagon:    {shape:'pentagon', hp:6, speed:70, color:'#8b5cff', immune:{splash:true}, xp:2},
  hexagon:     {shape:'hexagon', hp:12, speed:72, color:'#4caf50', immune:{poison:true}, xp:3},
  heptagon:    {shape:'heptagon', hp:13, speed:95, color:'#2b7f37', immune:{}, xp:4},
  octagon:     {shape:'octagon', hp:10, speed:58, color:'#ff79b1', immune:{}, xp:3},
  heavy:       {shape:'hendecagon', hp:20, speed:26, color:'#0f2f66', immune:{all:true}, xp:6},
  boss:        {shape:'ennea', hp:60, speed:16, color:'#6b2a6b', immune:{}, xp:20},
  pentadecagon:{shape:'pentadecagon', hp:8, speed:22, color:'#ff9ad1', immune:{}, xp:4, ranged:true, damage:3, rate:0.6}
};

/* ---------------- Waves: first 10 preset, then random ----------------
   Each wave is an array of enemy 'templateName' strings or special objects
*/
const PRESET_WAVES = [
  // wave index starting at 1
  ['circle','circle','circle','circle','circle'],                                   // 1
  Array(10).fill('circle').concat(['square']),                                     // 2
  Array(5).fill('square'),                                                         // 3
  Array(10).fill('square').concat(Array(3).fill('triangle')),                      // 4
  Array(5).fill('triangle').concat(Array(3).fill('pentagon')),                     // 5
  Array(15).fill('circle').concat(Array(10).fill('square')).concat(Array(5).fill('triangle')), // 6
  Array(5).fill('pentagon'),                                                       // 7
  Array(10).fill('pentagon').concat(Array(3).fill('heptagon')).concat(['hexagon']),// 8
  Array(25).fill('circle').concat(Array(5).fill('octagon')).concat(Array(10).fill('square')), // 9
  ['circle','square','triangle','heavy']                                           // 10 (hendecagon~heavy)
];

// Wave description helper - classify wave for bottom text
function classifyWave(enemyList){
  // simple heuristics
  const counts = {};
  enemyList.forEach(n => counts[n] = (counts[n]||0)+1);
  const total = enemyList.length;
  // meatshield: lots of squares/circles and slow types
  const meatshieldScore = (counts['square']||0) + (counts['circle']||0) + (counts['heavy']||0);
  const spamScore = (counts['triangle']||0) + (counts['circle']||0);
  const rangedScore = (counts['pentadecagon']||0) + (counts['pentagon']||0) + (counts['hexagon']||0);
  if(total >= 20 && spamScore / total > 0.45) return 'Spam wave (lots of fast weak enemies)';
  if(meatshieldScore / Math.max(1,total) > 0.5) return 'Meatshield wave (tanky bodies up front)';
  if(rangedScore > 0) return 'Ranged wave (turrets and ranged threats)';
  if(total >= 15) return 'Hard / Mixed wave';
  return 'Normal wave';
}

/* ---------------- Engine state ---------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = CONFIG.canvas.w;
canvas.height = CONFIG.canvas.h;

let keys = {};
let lastTime = performance.now();
let enemies = [];
let bullets = [];      // friendly projectiles
let enemyBullets = []; // enemy projectiles
let orbs = [];         // rotating orbs maintained per weapon instance
let minions = [];
let effects = [];
let spawnQueue = [];   // pending enemies to spawn for current wave (names)
let wave = 1;
let waveInProgress = false;
let waveSpawnIndex = 0;
let waveEnemySpawnTimer = 0;
let gamePaused = false;
let cardOverlay = null;

// Player
let player = {
  x: canvas.width/2, y: canvas.height/2,
  hp: CONFIG.player.maxHp, maxHp: CONFIG.player.maxHp,
  speed: CONFIG.player.speed, level:1, xp:0, kills:0,
  ownedWeapons:{}, currentWeaponId:null
};

// utils
const rand = (a,b)=> a + Math.random()*(b-a);
const choose = arr => arr[Math.floor(Math.random()*arr.length)];
const dist = (x1,y1,x2,y2)=> Math.hypot(x1-x2,y1-y2);
const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
const now = ()=> performance.now();

// create weapon instance
function createWeaponInstance(id){
  const t = WEAPON_TEMPLATES[id];
  if(!t) return null;
  return {
    id: t.id, name: t.name, type: t.type,
    baseDamage: t.baseDamage,
    data: JSON.parse(JSON.stringify(t.data || {})),
    desc: t.desc, lastShot: 0, minionType:'base'
  };
}

// initial random weapon
(function initWeapon(){
  const keys = Object.keys(WEAPON_TEMPLATES);
  const pick = keys[Math.floor(Math.random()*keys.length)];
  player.ownedWeapons[pick] = createWeaponInstance(pick);
  player.currentWeaponId = pick;
})();

/* ---------------- Input ---------------- */
window.addEventListener('keydown', e=> { keys[e.key.toLowerCase()] = true; if(e.key === ' '){ e.preventDefault(); }});
window.addEventListener('keyup', e=> { keys[e.key.toLowerCase()] = false; });

/* ---------------- Spawn helpers ---------------- */
function spawnEnemyByName(name, extra){
  const template = ENEMIES[name] || ENEMIES.circle;
  // spawn around edges
  const side = Math.floor(Math.random()*4);
  let x,y;
  if(side===0){ x = -30; y = rand(30, canvas.height-30);}
  else if(side===1){ x = canvas.width+30; y = rand(30, canvas.height-30);}
  else if(side===2){ y = -30; x = rand(30, canvas.width-30);}
  else { y = canvas.height+30; x = rand(30, canvas.width-30);}
  const e = {
    id: 'e_'+Math.random().toString(36).slice(2),
    name, templateName: name, shape: template.shape,
    hp: template.hp, maxHp: template.hp,
    speed: template.speed, color: template.color,
    size: 10 + template.hp/5,
    immune: template.immune || {},
    xp: template.xp || 1,
    ranged: template.ranged || false,
    damage: template.damage || 1,
    rate: template.rate || 0.8,
    lastShot: 0,
    // behaviors
    aiKeepDist: !!template.ranged, // pentadecagon keeps distance and shoots
    target: null
  };
  enemies.push(e);
}

/* ---------------- Wave system ---------------- */
function prepareWave(n){
  wave = n;
  enemies.length = 0;
  bullets.length = 0;
  enemyBullets.length = 0;
  orbs.length = 0;
  minions.length = 0;
  spawnQueue.length = 0;
  waveInProgress = true;
  waveSpawnIndex = 0;
  waveEnemySpawnTimer = 0;
  // fill spawnQueue from preset or random
  if(n <= PRESET_WAVES.length){
    spawnQueue.push(...PRESET_WAVES[n-1]);
  } else {
    // random generation biased by wave (harder shapes at higher waves)
    const count = Math.min(30, 4 + Math.floor(n*1.3));
    const pool = [];
    // lower waves: more circles/triangles; higher waves: include heavy & boss rarely
    for(let i=0;i<count;i++){
      const r = Math.random();
      if(n < 6){
        pool.push(Math.random() < 0.65 ? 'circle' : (Math.random()<0.5 ? 'triangle' : 'square'));
      } else if(n < 10){
        pool.push(Math.random()<0.5 ? 'square' : (Math.random()<0.55 ? 'circle' : 'pentagon'));
      } else {
        // higher waves: include heavy-ish types more often
        const pick = Math.random();
        if(pick < 0.12) pool.push('heavy');
        else if(pick < 0.22) pool.push('heptagon');
        else if(pick < 0.35) pool.push('pentadecagon');
        else if(pick < 0.6) pool.push('square');
        else pool.push('circle');
      }
    }
    spawnQueue.push(...pool);
  }
  // set wave description text
  const desc = classifyWave(spawnQueue);
  document.getElementById('waveDesc').innerText = `Wave ${n} - ${desc}`;
  // start spawning sequence (spawnQueue will be fed into spawn every N ms)
}

// start first wave
prepareWave(1);

/* ---------------- Weapon fire handlers ---------------- */
function ensureOrbs(w){
  // ensure orbs[] contains orbs that belong to player weapon id
  const existing = orbs.filter(o => o.owner === w.id);
  while(existing.length < (w.data.count||1)){
    const orb = { owner: w.id, angle: Math.random()*Math.PI*2, dist: 34 + (w.data.count*6), r:8, damage: w.baseDamage };
    orbs.push(orb);
    existing.push(orb);
  }
}

function fireProjectiles(w, overrideAngle){
  // buckshot & rocket & ring
  if(w.id === 'buckshot'){
    const target = findClosestEnemy(player.x, player.y);
    let base = target ? Math.atan2(target.y - player.y, target.x - player.x) : overrideAngle || rand(0,Math.PI*2);
    const bulletsCount = w.data.bullets || 5;
    const spread = w.data.spread || 0.6;
    for(let i=0;i<bulletsCount;i++){
      const a = base + (i - (bulletsCount-1)/2) * (spread / bulletsCount);
      bullets.push({x:player.x, y:player.y, vx: Math.cos(a)*(w.data.speed||360), vy: Math.sin(a)*(w.data.speed||360), damage: w.baseDamage || 1, life: 1500, owner:'player'});
    }
  } else if(w.id === 'rocket'){
    const target = findClosestEnemy(player.x, player.y);
    let a = target ? Math.atan2(target.y - player.y, target.x - player.x) : overrideAngle || rand(0,Math.PI*2);
    bullets.push({x:player.x, y:player.y, vx: Math.cos(a)*(w.data.speed||220), vy: Math.sin(a)*(w.data.speed||220), damage: w.baseDamage || 3, life: 3000, owner:'player', splash: w.data.splash || 28, splashDamage: w.data.splashDamage || 2});
  } else {
    // general projectile (ring)
    const spd = w.data.speed || 260;
    const dirs = w.data.dirs || 8;
    for(let i=0;i<dirs;i++){
      const a = (i/dirs)*Math.PI*2;
      bullets.push({x:player.x, y:player.y, vx: Math.cos(a)*spd, vy: Math.sin(a)*spd, damage: w.baseDamage || 1, life: 1200, owner:'player'});
    }
  }
}

function fireChain(w){
  // very simplified chain: instant zap to nearest enemy within range (apply damage)
  const target = findClosestEnemy(player.x, player.y);
  if(target && dist(player.x,player.y,target.x,target.y) < (w.data.range||120)){
    // create damage effect (we handle enemy damage in update loop by consuming a hit marker)
    target.hp -= w.baseDamage || 1;
    spawnEffect(target.x, target.y, 'zap');
    if(target.hp <= 0) enemyDie(target);
    // chain to more nearby enemies
    let chained = 0;
    for(const e of enemies){
      if(e === target) continue;
      if(dist(target.x,target.y,e.x,e.y) < 80 && chained < (w.data.chains-1)){
        e.hp -= w.baseDamage || 1;
        spawnEffect(e.x,e.y,'zap');
        if(e.hp <= 0) enemyDie(e);
        chained++;
      }
    }
  }
}

function fireScythe(w){
  // throw a projectile that pierces and applies poison
  const target = findClosestEnemy(player.x, player.y);
  const a = target ? Math.atan2(target.y-player.y, target.x-player.x) : rand(0,Math.PI*2);
  bullets.push({x:player.x, y:player.y, vx: Math.cos(a)*480, vy: Math.sin(a)*480, damage: w.baseDamage || 0, life: 1600, owner:'player', pierce:true, poison: w.data.poison, poisonTime: w.data.lifetime});
}

function spawnMinionFromPlayer(w){
  // spawn small minion that targets enemies
  const t = { x: player.x + rand(-12,12), y: player.y + rand(-12,12), vx:0, vy:0, hp: 4, maxHp:4, damage: w.baseDamage || 1, owner:'player', ttl: 14000, type: w.minionType || 'base' };
  minions.push(t);
}

/* ---------------- AI / update ---------------- */
function findClosestEnemy(x,y){
  if(enemies.length===0) return null;
  let best=null, bestd=1e9;
  for(const e of enemies){
    const d = dist(x,y,e.x,e.y);
    if(d < bestd){ bestd = d; best = e; }
  }
  return best;
}

function enemyDie(e){
  try { // safe removal
    player.xp += e.xp || 1;
    player.kills++;
    const idx = enemies.indexOf(e); if(idx>=0) enemies.splice(idx,1);
  } catch(err){}
  // check level up
  while(player.xp >= CONFIG.xpToLevel(player.level)){
    player.xp -= CONFIG.xpToLevel(player.level);
    player.level++;
    // show level-up card (choose 3 random cards - weapon or upgrade only for owned weapons)
    presentCardsForLevel();
    // pause further immediate progress
    break;
  }
}

function spawnEffect(x,y,type){
  effects.push({x,y,type, life: 400, t:0});
}

/* ---------------- Wave spawn ticking ---------------- */
function updateWaveSpawning(dt){
  if(!waveInProgress) return;
  if(spawnQueue.length === 0 && enemies.length === 0 && enemyBullets.length === 0 && minions.length === 0){
    // wave cleared -> prepare next
    waveInProgress = false;
    setTimeout(()=> prepareWave(wave+1), 700);
    return;
  }
  // spawn from spawnQueue gradually
  if(spawnQueue.length > 0){
    waveEnemySpawnTimer -= dt;
    if(waveEnemySpawnTimer <= 0){
      const name = spawnQueue.shift();
      if(name) spawnEnemyByName(name);
      waveEnemySpawnTimer = CONFIG.spawnDelayBetweenWaveEnemies;
    }
  }
}

/* ---------------- Update loop ---------------- */
function update(dt){
  if(gamePaused) return;
  // player movement
  let mx = 0, my = 0;
  if(keys['w'] || keys['arrowup']) my -=1;
  if(keys['s'] || keys['arrowdown']) my +=1;
  if(keys['a'] || keys['arrowleft']) mx -=1;
  if(keys['d'] || keys['arrowright']) mx +=1;
  const mlen = Math.hypot(mx,my) || 1;
  player.x += (mx/mlen) * player.speed * dt/1000;
  player.y += (my/mlen) * player.speed * dt/1000;
  player.x = clamp(player.x, 8, canvas.width-8);
  player.y = clamp(player.y, 8, canvas.height-8);

  // weapon auto-fire (simple: player always fires)
  const weapon = player.ownedWeapons[player.currentWeaponId];
  if(weapon){
    const t = now();
    const elapsed = (t - (weapon.lastShot||0))/1000;
    const rate = (weapon.data && weapon.data.rate) || 1.0;
    if(elapsed >= (1/rate)){
      weapon.lastShot = t;
      // dispatch type
      if(weapon.type === 'projectile') fireProjectiles(weapon);
      else if(weapon.type === 'orb') ensureOrbs(weapon); // orbs are handled in draw & collision
      else if(weapon.type === 'chain') fireChain(weapon);
      else if(weapon.type === 'scythe') fireScythe(weapon);
      else if(weapon.type === 'minions') spawnMinionFromPlayer(weapon);
      else if(weapon.type === 'ring') fireProjectiles(weapon);
    }
  }

  // update bullets (friendly)
  for(let i = bullets.length-1; i>=0; i--){
    const b = bullets[i];
    b.x += b.vx * dt/1000;
    b.y += b.vy * dt/1000;
    b.life -= dt;
    // check collisions with enemies
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      if(dist(b.x,b.y,e.x,e.y) < e.size + 4){
        // hit
        e.hp -= b.damage || 1;
        spawnEffect(b.x,b.y,'hit');
        if(b.pierce !== true){ bullets.splice(i,1); break; }
        // else piercing bullets continue
      }
    }
    if(b && b.life <= 0) bullets.splice(i,1);
  }

  // update enemy bullets
  for(let i = enemyBullets.length-1;i>=0;i--){
    const b = enemyBullets[i];
    b.x += b.vx * dt/1000;
    b.y += b.vy * dt/1000;
    b.life -= dt;
    if(dist(b.x,b.y,player.x,player.y) < 10 + (b.radius||4)){
      player.hp -= b.damage || 1;
      spawnEffect(player.x, player.y, 'playerhit');
      enemyBullets.splice(i,1);
      continue;
    }
    if(b.life <= 0) enemyBullets.splice(i,1);
  }

  // update enemies AI and movement
  for(let i = enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(e.aiKeepDist){
      // pentadecagon behavior: maintain a distance from player and shoot slowly
      const desiredDist = 160;
      const dx = player.x - e.x, dy = player.y - e.y;
      const d = Math.hypot(dx,dy);
      // if too close, move away, if too far, move slightly towards
      let nx=0, ny=0;
      if(d < desiredDist-20){ nx = -dx/d; ny = -dy/d; }
      else if(d > desiredDist+40){ nx = dx/d; ny = dy/d; }
      e.x += nx * e.speed * dt/1000;
      e.y += ny * e.speed * dt/1000;
      // shooting
      e.lastShot += dt;
      if(e.lastShot > (1000 / (e.rate||0.6))){
        e.lastShot = 0;
        // shoot towards player: create enemy projectile
        const a = Math.atan2(player.y - e.y, player.x - e.x);
        const spd = 260;
        enemyBullets.push({x:e.x, y:e.y, vx: Math.cos(a)*spd, vy: Math.sin(a)*spd, damage: e.damage||3, life: 3000, owner:'enemy', radius:6});
      }
    } else {
      // basic seek player
      const dx = player.x - e.x, dy = player.y - e.y;
      const d = Math.hypot(dx,dy) || 1;
      e.x += (dx/d) * e.speed * dt/1000;
      e.y += (dy/d) * e.speed * dt/1000;
    }
    // apply poison if any
    if(e.poison && e.poison > 0){
      // simple poison tick
      e.hp -= (e.poison * dt/1000) * 0.5;
    }
    // check collision with player (enemy touches player deals damage)
    if(dist(e.x,e.y,player.x,player.y) < e.size + 10){
      player.hp -= 0.6 * dt/1000; // continuous damage while in contact
    }
    // remove if dead
    if(e.hp <= 0){
      enemyDie(e);
    }
  }

  // orbs rotation around player (for rotating_orb weapon)
  for(const o of orbs){
    o.angle += (o.owner && player.ownedWeapons[o.owner] ? player.ownedWeapons[o.owner].data.speed : 2.5) * dt/1000;
    o.x = player.x + Math.cos(o.angle) * (o.dist || 40);
    o.y = player.y + Math.sin(o.angle) * (o.dist || 40);
    // check collisions vs enemies
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      if(dist(o.x,o.y,e.x,e.y) < e.size + o.r){
        e.hp -= (player.ownedWeapons[o.owner] ? player.ownedWeapons[o.owner].baseDamage : 1) * dt/1000 * 60 / 4; // scaled per tick
        spawnEffect(e.x,e.y,'hit');
        if(e.hp <= 0) enemyDie(e);
      }
    }
  }

  // minions movement & attacks
  for(let i=minions.length-1;i>=0;i--){
    const m = minions[i];
    m.ttl -= dt;
    const target = findClosestEnemy(m.x,m.y);
    if(target){
      const dx = target.x - m.x, dy = target.y - m.y;
      const d = Math.hypot(dx,dy) || 1;
      m.x += (dx/d) * 80 * dt/1000;
      m.y += (dy/d) * 80 * dt/1000;
      if(dist(m.x,m.y,target.x,target.y) < 10){
        target.hp -= m.damage * dt/1000 * 30;
        if(target.hp <= 0) enemyDie(target);
      }
    } else {
      // idle near player
      m.x += (player.x - m.x) * 0.06;
      m.y += (player.y - m.y) * 0.06;
    }
    if(m.ttl <= 0) minions.splice(i,1);
  }

  // effects lifetime
  for(let i=effects.length-1;i>=0;i--){
    const ef = effects[i]; ef.t += dt; ef.life -= dt; if(ef.life <= 0) effects.splice(i,1);
  }

  // cp: enemy bullets handled earlier

  // spawn queue and wave spawning
  updateWaveSpawning(dt);

  // check death
  if(player.hp <= 0){
    // reset game (very simple)
    alert('You died! Restarting run.');
    location.reload();
  }

  // UI updates
  document.getElementById('hpfill').style.width = `${(player.hp/player.maxHp)*100}%`;
  document.getElementById('ui-text').innerText = `XP: ${Math.floor(player.xp)} | Level: ${player.level} | Weapon: ${player.currentWeaponId}`;
  document.getElementById('bottomstats').innerText = `Wave: ${wave} | Enemies: ${enemies.length} Bullets: ${bullets.length + enemyBullets.length} XP:${Math.floor(player.xp)}/${CONFIG.xpToLevel(player.level)}`;
}

/* ---------------- Present Level-up Cards ----------------
   Pause the game, present 3 cards, each either a new weapon or an upgrade for an owned weapon.
   Upgrades that require owning a weapon will not be shown unless owned.
*/
function presentCardsForLevel(){
  gamePaused = true;
  // build card options
  const availableWeaponIds = Object.keys(WEAPON_TEMPLATES);
  const owned = Object.keys(player.ownedWeapons);
  // gather candidate cards
  const cards = [];
  // include one new weapon option and two upgrades (if possible)
  // New weapon:
  const notOwned = availableWeaponIds.filter(id => !owned.includes(id));
  if(notOwned.length > 0){
    const pick = choose(notOwned);
    const wt = WEAPON_TEMPLATES[pick];
    cards.push({type:'weapon', id:pick, title: wt.name, desc: wt.desc});
  }
  // then fill up to 3 choices with upgrades or weapons
  while(cards.length < 3){
    if(Math.random() < 0.55 && owned.length > 0){
      // pick an owned weapon and pick a random upgrade for it
      const wId = choose(owned);
      const ups = UPGRADE_OPTIONS[wId] || [];
      if(ups.length > 0){
        const up = choose(ups);
        // ensure we don't duplicate same exact title already in cards for same weapon
        if(!cards.find(c=>c.type==='upgrade' && c.weapon===wId && c.title===up.title)){
          cards.push({type:'upgrade', weapon:wId, apply: up.apply, title:`${player.ownedWeapons[wId].name}: ${up.title}`, desc: up.desc, upgradeRef: up});
        } else continue;
      } else {
        // fallback to offering new weapon if exists
        if(notOwned.length>0) cards.push({type:'weapon', id: choose(notOwned), title:'New Weapon', desc:'A new weapon.'});
        else break;
      }
    } else {
      // offer new weapon if any
      if(notOwned.length>0) cards.push({type:'weapon', id: choose(notOwned), title: WEAPON_TEMPLATES[choose(notOwned)]?.name || 'Weapon', desc: 'New weapon.'});
      else if(owned.length>0){
        // offer random upgrade for owned
        const wId = choose(owned); const ups = UPGRADE_OPTIONS[wId] || [];
        if(ups.length>0) cards.push({type:'upgrade', weapon:wId, apply: choose(ups).apply, title:`${player.ownedWeapons[wId].name}: Upgrade`, desc:'Upgrade.'});
        else break;
      } else break;
    }
  }
  // ensure exactly 3 cards (duplicate near-miss choices allowed)
  while(cards.length < 3) cards.push({type:'weapon', id: choose(Object.keys(WEAPON_TEMPLATES)), title:'Bonus', desc:'Small bonus.'});

  // build overlay DOM
  const overlay = document.createElement('div'); overlay.className = 'overlay';
  const panel = document.createElement('div'); panel.className = 'card-panel';
  cards.forEach((c, idx) => {
    const card = document.createElement('div'); card.className='card';
    const title = document.createElement('div'); title.className='title'; title.innerText = c.title;
    const desc = document.createElement('div'); desc.className='desc'; desc.innerText = c.desc;
    card.appendChild(title); card.appendChild(desc);
    card.onclick = () => {
      // apply choice
      if(c.type === 'weapon'){
        // give player a weapon instance
        player.ownedWeapons[c.id] = createWeaponInstance(c.id);
        player.currentWeaponId = c.id; // auto equip
      } else if(c.type === 'upgrade'){
        // apply to player's weapon instance
        const inst = player.ownedWeapons[c.weapon];
        if(inst && c.apply) c.apply(inst);
      }
      // remove overlay and resume
      document.body.removeChild(overlay);
      gamePaused = false;
    };
    panel.appendChild(card);
  });
  overlay.appendChild(panel);
  document.body.appendChild(overlay);
}

/* ---------------- Draw ---------------- */
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw grid-ish (subtle)
  ctx.fillStyle = '#fafafa';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw enemies
  for(const e of enemies){
    // shape rendering thumbnail (we'll approximate shapes with circles/squares/triangles)
    ctx.save();
    ctx.translate(e.x, e.y);
    // health bar
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.fillRect(-e.size-1, -e.size-10, (e.size*2)+2, 6);
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillRect(-e.size-1, -e.size-10, (e.size*2)+2, 6);
    ctx.fillStyle = 'rgba(255,255,255,0.0)';
    // hp fill
    const frac = clamp(e.hp/e.maxHp,0,1);
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(-e.size, -e.size-10, (e.size*2)*frac, 6);
    // shape
    ctx.beginPath();
    ctx.fillStyle = e.color || '#ff5a5a';
    if(e.shape === 'square'){
      ctx.fillRect(-e.size, -e.size, e.size*2, e.size*2);
    } else if(e.shape === 'triangle'){
      ctx.moveTo(0, -e.size);
      ctx.lineTo(e.size, e.size);
      ctx.lineTo(-e.size, e.size);
      ctx.closePath(); ctx.fill();
    } else {
      // circle & other shapes fallback to circle
      ctx.arc(0,0,e.size,0,Math.PI*2); ctx.fill();
    }
    // outline
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.stroke();
    ctx.restore();
  }

  // draw bullets (friendly)
  for(const b of bullets){
    ctx.beginPath();
    ctx.fillStyle = '#58aaff';
    ctx.arc(b.x, b.y, 4,0,Math.PI*2); ctx.fill();
  }
  // enemy bullets
  for(const b of enemyBullets){
    ctx.beginPath();
    ctx.fillStyle = '#ff8b8b';
    ctx.arc(b.x, b.y, b.radius||4,0,Math.PI*2); ctx.fill();
  }

  // draw orbs
  for(const o of orbs){
    ctx.beginPath();
    ctx.fillStyle = '#3b82f6';
    ctx.arc(o.x, o.y, o.r,0,Math.PI*2); ctx.fill();
  }

  // draw minions
  for(const m of minions){
    ctx.save();
    ctx.translate(m.x,m.y);
    if(m.type === 'square'){
      ctx.fillStyle = '#1f6fb3';
      ctx.fillRect(-6,-6,12,12);
    } else {
      ctx.fillStyle = '#5fb0ff';
      ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // draw player
  ctx.beginPath();
  ctx.fillStyle = '#0b66ff';
  ctx.arc(player.x, player.y, 10, 0, Math.PI*2); ctx.fill();
  // player outline
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(11,102,255,0.14)'; ctx.stroke();

  // effects
  for(const ef of effects){
    if(ef.type === 'hit'){
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,180,180,0.6)';
      ctx.arc(ef.x,ef.y, 6*(ef.life/400),0,Math.PI*2); ctx.fill();
    } else if(ef.type === 'zap'){
      ctx.beginPath();
      ctx.fillStyle = 'rgba(180,220,255,0.6)';
      ctx.arc(ef.x,ef.y, 8*(ef.life/400),0,Math.PI*2); ctx.fill();
    } else if(ef.type === 'playerhit'){
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,220,180,0.6)';
      ctx.arc(ef.x,ef.y, 12*(ef.life/400),0,Math.PI*2); ctx.fill();
    }
  }
}

/* ---------------- Game loop ---------------- */
function tick(){
  const t = performance.now();
  const dt = t - lastTime;
  lastTime = t;
  update(dt);
  draw();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---------------- Helper: spawn initial enemies for current wave start ---------------- */
(function startWaveFlow(){
  // ensure spawnQueue processed from prepareWave already; prepareWave called earlier for wave1
  setInterval(()=> {
    // ensure spawnQueue is checked (wave spawn is handled in updateWaveSpawning)
  }, 500);
})();

/* ---------------- Small customization helpers for quick editing ---------------- */
// Allow switching weapon via number keys 1-7
window.addEventListener('keydown', e=>{
  if(e.key >= '1' && e.key <= '9'){
    const owned = Object.keys(player.ownedWeapons);
    const idx = parseInt(e.key)-1;
    if(owned[idx]) player.currentWeaponId = owned[idx];
  }
  // cheat spawn next wave: N
  if(e.key.toLowerCase() === 'n') prepareWave(wave+1);
});

// Basic click to choose weapon for testing in UI (not required)
canvas.addEventListener('dblclick', ()=> {
  // give a new random weapon for fun
  const all = Object.keys(WEAPON_TEMPLATES);
  const pick = choose(all);
  player.ownedWeapons[pick] = createWeaponInstance(pick);
  player.currentWeaponId = pick;
});

</script>
</body>
</html>
